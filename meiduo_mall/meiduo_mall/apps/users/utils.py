from django.contrib.auth.backends import ModelBackendimport refrom django.conf import settingsfrom itsdangerous import TimedJSONWebSignatureSerializer, BadDatafrom .models import Userdef jwt_response_payload_handler(token, user=None, request=None):    """重写JWT登录视图的构造响应数据函数,多追加 user_id和username"""    return {        'token': token,        'user_id': user.id,        'username': user.username    }def get_user_by_account(account):    """    通过传入的账号动态获取user 模型对象    :param account:  有可以是手机号,有可能是用户名    :return:  user或None    """    try:        if re.match(r'1[3-9]\d{9}$', account):            user = User.objects.get(mobile=account)        else:            user = User.objects.get(username=account)    except User.DoesNotExist:        return None  # 如果没有查到返回None    else:        return user  # 注意不要写在模型类class UsernameMobileAuthBackend(ModelBackend):    """修改Django的认证类,为了实现多账号登录"""    def authenticate(self, request, username=None, password=None, **kwargs):        # 获取到user        user = get_user_by_account(username)        # 判断当前前端传入的密码是否正确        if user and user.check_password(password):            # 返回user            return userdef generate_access_token(data):    """生成找回密码的access_token"""    serializer = TimedJSONWebSignatureSerializer(settings.SECRET_KEY, 300)    token = serializer.dumps(data).decode()    return tokendef check_access_token(token):    """检查找回密码的access_token"""    serializer = TimedJSONWebSignatureSerializer(settings.SECRET_KEY, 300)    try:        data = serializer.loads(token)    except BadData:        return None    else:        return data